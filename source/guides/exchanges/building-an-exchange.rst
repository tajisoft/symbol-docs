####################
Building an Exchange
####################

This document is intended to **guide developers** through the integration of the ``XYM`` token into an **Exchange platform**. It contains recommendations on
how to set up accounts, listen for deposits, and create withdrawals as well as code examples ready to be adopted.

The code examples shared use the `Symbol SDK for TypeScript <https://github.com/nemtech/symbol-sdk-typescript-javascript>`__, but can be ported to other `available SDKs <https://nemtech.github.io/sdk.html>`__ since all of them share the same design principles. If there is no SDK supported for a required
programming language, you may still be able to integrate by connecting directly via Symbol's `REST API <https://nemtech.github.io/api.html>`__.

Integration overview
********************

There are many ways to design an exchange. This guide is based on how to support ``XYM`` deposits and withdrawals in an exchange that follows a **central wallet approach**.

Please note that this design is not particularly recommend over others. However, its **simplified architecture** is a good showcase for Symbol's set of features involved in building an Exchange. A different approach, for example, would be to use a different wallet for each user.

.. figure:: /resources/images/diagrams/exchange-integration-overview.png
   :align: center
   :width: 100%
   :target: /_images/exchange-integration-overview.png

   **Fig. 1**: General design diagram of the central wallet approach.

The main components of this architecture are described next.

Components
==========

Central wallet
--------------

The exchange owns a Symbol account where all the user's deposits and withdrawals occur. This account only has the necessary amount of XYM for daily use (withdrawals and deposits), since it is the account most exposed to attacks.

To increase the account security, we highly recommend to set up the wallet using Symbol's `multisig feature <https://nemtech.github.io/concepts/multisig-account.html>`__. Withdrawals can be automated using bots to ensure wallet security with **two-factor authentication**.

Cold wallet
-----------

Cold wallet(s) hold a certain threshold for the pool of XYM. These accounts should be created and remain in a setup with no internet connection. Transactions issued from cold wallets must be signed offline and announced to the network using another device. It is advisable as well that cold wallets are set up with `multisig accounts <https://nemtech.github.io/concepts/multisig-account.html>`__, this time controlled by people.

Unique User ID
--------------

Each user is identified by a unique identifier (UUID) on the exchange's database. A user will deposit to the central wallet with their UUID attached as
the `message <https://nemtech.github.io/concepts/transfer-transaction.html>`__ of the transaction (called sometimes the **memo**). The UUID is only shown
in the user's dashboard during the deposit confirmation.

One of the drawbacks of this design is that many users are not used to having a message attached to their transactions. If they forget to attach the UUID or attach a wrong UUID, it will lead to receiving lots of support tickets concerning "lost funds".

.. caution::

   Symbol's `Transfer transactions <https://docs.symbolplatform.com/concepts/transfer-transaction>`__ can hold an arbitrary `message <https://docs.symbolplatform.com/concepts/transfer-transaction.html#message>`__ up to 1023 bytes long but **the first byte is treated specially by the** `Symbol SDK <https://docs.symbolplatform.com/sdk.html>`__.

   This can be a source of confusion because the receiver of a transaction does not know if the message was generated by the Symbol SDK or otherwise (for example accessing the `REST gateway <https://docs.symbolplatform.com/api.html>`__), so it does not know if the first byte must be treated specially or not.

   To avoid any issue, the following measures **must always be enforced**:

   - **Always** start messages with a byte in the 32 to 128 range (this is the standard ASCII printable range).
   - **Always** ignore any received initial byte outside the 32 to 128 range.

   Follow these rules, regardless of whether you use the Symbol SDK or not to generate and parse transfer transactions.

Exchange Server
---------------

This machine is constantly listening for user's withdraw requests, and monitors the blockchain to detect user deposits into the Exchange Central Wallet. As explained in the rest of this document, it maintains the database updated and announces any required transaction.

Exchange Database
-----------------

All the user's funds are merged together in the Exchange's wallets. This database keeps track of the amount of tokens each individual user holds. It also records all processed transactions, for record-keeping and to avoid processing the same transaction more than once.

Running a node
==============

Although not absolutely necessary, it is **recommended** that Exchanges deploy **their own Symbol node** to communicate with the rest of the network. This is more robust than accessing the network always through the same public node, which might become unavailable.

See the `different guides about deploying Symbol nodes <https://docs.symbolplatform.com/guides/network>`__ and make sure you create an `API node <https://docs.symbolplatform.com/concepts/node.html#api-node>`__.

Setting up accounts
===================

Exchanges can create the central and cold wallets by `downloading the official Symbol Desktop Wallet <https://github.com/nemgrouplimited/symbol-desktop-wallet/releases>`__ for **Windows**, **Linux** or **Mac**.

Every wallet has assigned an `account <https://nemtech.github.io/concepts/account.html>`__ (a deposit box that holds tokens, which can only be transferred with the appropriate private key).

.. caution:: The **private key must be kept secret at all times** and must not be shared. Losing the private key means losing access to an account's funds, so make sure it is **securely backed up**.

It is advisable to turn central and cold wallets into `multisig accounts <https://nemtech.github.io/concepts/multisig-account.html>`__ to add **two-factor authentication**. The cosignatories of the multisig account become the account managers, so no transaction can be announced from the multisig account without the cosignatories' approval. Symbol's current implementation of multisig is **“M-of-N”** meaning that *M* out of the total *N* cosignatories of an account need to approve a transaction for it to be announced.

.. caution:: Multisig accounts are a **powerful** yet **dangerous** tool. If access to some cosignatory account is lost and the minimum approval is not reached (the *M* above), access to the multisig account can be permanently lost. **Always configure multisig accounts with caution**.

To strengthen security, `extra account restrictions <https://nemtech.github.io/concepts/account-restriction.html>`__ can be added to the Exchange's accounts, like blocking announcing or receiving transactions given a series of rules.

.. topic:: Related links

   - `Download the Symbol client <https://github.com/nemgrouplimited/symbol-desktop-wallet/releases>`__
   - `How to create a new account <https://docs.symbolplatform.com/guides/account/creating-an-account.html>`__
   - `How to turn an account into a multisig account <https://nemtech.github.io/guides/multisig/converting-an-account-to-multisig.html>`__
   -  `How to set account restrictions <https://nemtech.github.io/guides/restriction/preventing-spam-attacks-with-account-restrictions.html>`__

The XYM token
=============

The native currency of the Symbol network is named ``XYM``. The token is used to pay for transactions and service `fees <https://nemtech.github.io/concepts/fees. tml>`__, which are used as well to provide an incentive for those `participants <https://nemtech.github.io/concepts/harvesting>`__ who secure the network and run the infrastructure.

Tokens can be divided up to ``divisibility`` decimal places. Amounts given without decimals are called **absolute**, whereas when decimals are used amounts are called **relative**. For example, when divisibility is 6, 1 relative token corresponds to 1'000'000 absolute tokens, and the smallest token is 0.000001 relative units. The smallest absolute unit is always 1, regardless of the divisibility.

These are the properties of ``XYM``:

.. csv-table::
   :header: "Property", "Value", "Description"
   :delim: ;
   :widths: 20 25 55

   ID; ``0x6BED913FA20223F8``; Token unique identifier
   Alias; ``symbol.xym``; Friendly name for the token
   Initial supply; 7'842'928'625 (relative); Initial amount of token units in circulation
   Max supply; 8'999'999'999 (relative); Maximum amount of token units in circulation after `inflation <https://nemtech.github.io/concepts/inflation.html>`__ is applied
   Divisibility; 6; This means that the smallest fraction of the token is 0.000001 (relative).
   Duration; 0; Token does not expire
   Supply mutable; False; Token supply cannot be altered
   Transferable; True; Token can be transferred between arbitrary accounts
   Restrictable; False; Token creator cannot restrict which accounts can transact with the mosaic

.. caution::

   The ``XYM`` token can be referred to through its **native token ID** or its **friendlier alias** ``symbol.xym``, which has an ID on itself.

   On MAINNET, these IDs are ``0x6BED913FA20223F8`` (mosaic ID) and ``0xE74B99BA41F4AFEE`` (alias ID).

   **Always treat these two IDs as equivalent.**

Incoming deposits
*****************

.. figure:: /resources/images/diagrams/exchange-integration-deposit.png
   :align: center
   :width: 100%
   :target: /_images/exchange-integration-deposit.png

   **Fig. 2**: Deposit process.

Users perform deposits by announcing a regular transfer transaction using their wallet, moving the funds from their account directly to the Exchange Central Wallet. Since the transfer is handled entirely by the blockchain, the funds will be added to the Exchange Central Wallet without the Exchange's mediation, and this poses some problems:

- The **intended recipient** of the transaction must be determined. This is done by attaching the user's UUID as the transaction's message.
- Transactions must be **finalized** to be 100% sure that they will not be `rolled back <https://docs.symbolplatform.com/concepts/block.html#rollbacks>`__.
- The fact that a transaction has happened must be timely detected to update the user's account on the Exchange.

These issues are addressed in the following sections.

Avoiding rollbacks
==================

This is a **classic conflict** in blockchain technology: On one hand, if transactions are accepted too quickly, they might need to be **reverted** later on in the event of a `network fork <https://docs.symbolplatform.com/concepts/block.html#rollbacks>`__. On the other hand, waiting for too long is **inconvenient** for users.

There are two ways of dealing with this in Symbol:

- **Using Finalization:**

  Symbol implements `Finalization <https://docs.symbolplatform.com/concepts/block.html#finalization>`__, a process that **guarantees** that blocks are **immutable** and therefore transactions are secure.

  To know if a block has been finalized, check the ``latestFinalizedBlock`` property in the `/chain/info <https://docs.symbolplatform.com/symbol-openapi/v1.0.1/#operation/getChainInfo>`__ endpoint. All blocks with a **height** lower than (or equal to) ``latestFinalizedBlock.height`` are **finalized** and are therefore **immutable**. `See here for a real-time MAINNET example <http://ngl-dual-104.symbolblockchain.io:3000/chain/info>`__.

  **On average**, blocks are finalized after 5 minutes, in the absence of network problems.

- **Waiting a fixed number of blocks:**

  To have faster response times, one must ignore finalization and **accept the risk** that comes with this: **Unfinalized blocks have a probability of being reverted**, which decreases over time but is never zero until the block is finalized.

  The process is then to **wait for a few blocks** to be validated (added to the blockchain) before accepting a transaction.

  The amount of blocks to wait for depends on the risk one wants to accept. The recommendation for Symbol is **20 blocks** (about 10 minutes, regardless of network conditions).

**In summary:**

- Waiting for a **fixed amount** of blocks leads to consistent confirmation times, but has the risk that confirmed transactions might be reverted.
- Waiting for **finalization** has variable confirmation times (5 minutes on average) and has zero rollback risk.

For illustration purposes, the following sections provide code examples using both finalization and a fixed 20 blocks threshold.

Dealing with deadlines
======================

An added problem caused by rollbacks is that **transactions might expire** in the process of resolving a network fork.

A bit of context is required first. Transactions are not allowed to remain unconfirmed in the network forever, as this would pose a significant strain on the network's resources. Instead, **all transactions have a deadline**, and are automatically disposed of when the deadline arrives.

Users are free to use any deadline they want for their transactions, between now and 24h into the future.

Transactions which are about to expire are delicate because, even if they get confirmed and are added to the blockchain, **a rollback could send them back to the unconfirmed state** and their deadline could arrive before they are confirmed again.

Therefore, **it is recommended** that incoming transactions with a deadline **less than 1h into the future** are ignored, and Exchanges actively encourage their customers to avoid using transactions with short lifespans.

Code
====

The blockchain is polled periodically and all incoming transactions since last poll are processed in a batch:

1. All transactions added to the blockchain **since** the last check and **up to** the latest finalized block are examined, looking for the ones destined to the Central Exchange Wallet. This can be done efficiently with a single Symbol API call.

   Use the (current chain height - 20) instead of finalized block if finalization is not desired (see previous section).

2. Filter out transactions that:

   a. Have no message or the message does not correspond to an existing UUID.

   b. Do not contain tokens, or the token is not symbol.xym.

   c. Have already been processed (as a security measure).

3. The remaining transactions are then processed:

   a. The tokens are added to the user's account in the database.

   b. The transaction is marked as processed by adding its hash to the database

4. Store the last height that has been processed and wait for the next polling period.

The code snippet, using `Symbol's TypeScript SDK <https://docs.symbolplatform.com/symbol-sdk-typescript-javascript/1.0.0/>`__ is this:

.. example-code::

    .. viewsource:: ../../resources/examples/typescript/exchanges/ProcessDeposits.ts
        :language: typescript
        :start-after:  /* start block processDeposits */
        :end-before: /* end block processDeposits */

    .. viewsource:: ../../resources/examples/typescript/exchanges/ProcessDeposits.js
        :language: javascript
        :start-after:  /* start block processDeposits */
        :end-before: /* end block processDeposits */

The above code snippet can be called **in a loop** every minute, for example, and it will process **all new valid transactions** that have already been finalized (or that have waited enough blocks, depending on the chosen method).

However, **transactions will not be reported immediately**, and this might be annoying for users. Using `WebSockets <https://docs.symbolplatform.com/api. tml#websockets>`__ transactions can be monitored in real-time and a notification can be shown to the user as soon as a transaction is confirmed on the network
(or even as soon as it is announced).

These transactions, though, should be clearly marked as **pending** and **not acted upon** until verified by the above code, to `avoid rollbacks <#avoiding-rollbacks>`__.

.. topic:: Related links

   - `Transfer Transaction reference <https://nemtech.github.io/concepts/transfer-transaction.html>`__
   - `Mosaic (token) reference <https://nemtech.github.io/concepts/mosaic.html>`__
   - `Symbol API reference <https://nemtech.github.io/api.html>`__
   - `WebSockets reference <https://nemtech.github.io/api.html#websockets>`__

Withdrawals
***********

.. figure:: /resources/images/diagrams/exchange-integration-withdrawal.png
   :align: center
   :width: 100%
   :target: /_images/exchange-integration-withdrawal.png

   **Fig. 3**: Withdrawal process.

Users send withdrawal requests to the Exchange Server, via a web page or mobile app, for example. If the database indicates that the user has enough funds to perform the withdrawal, a `transfer transaction <https://nemtech.github.io/concepts/transfer-transaction.html>`__ is announced from the Exchange Central Wallet to the address indicated in the request.

Announcing the transaction has a `fee <https://nemtech.github.io/concepts/fees.html>`__, which is paid by the Exchange Central Wallet but can be deduced from the user's account. Regardless of the token being transferred, fees are always paid in XYM tokens.

Announcing a transaction is slightly different depending on whether the Exchange Central Wallet is a regular account or a multi-signature account.

Via a regular account
=====================

Via a multisig account
======================

Accepting other tokens stored in the Symbol blockchain
******************************************************

Testing the integration
***********************

On the public test network
==========================

On a private test network
=========================
